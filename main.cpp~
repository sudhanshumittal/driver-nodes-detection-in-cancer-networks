#include <iostream>
#include<sstream>
#include <fstream>
#include <vector>
#include <map>
#include <queue>
#include<cstdlib>
#include <limits>
#include<cmath>
using namespace std;

#define PEARSON_FACTOR 0.7f
#define XOR 'x'
#define NXOR 'n'
#define TINY_VALUE 1e-20
#define DONT_CARE '-'
int min(int a, int b);
//char getLabel(string xstr, string ystr);
char getLabel(map<string, map<string, float> >, string, string);
//double Correlation(const vector<double>& x, const vector<double>& y);
void printError(string a){
	/*ofstream fp;
	fp.open("log.txt", ios_base::app);
	fp<<a;
	fp.close();*/
	cout<<a;
	exit(1);
}
class node{
public:
    class edge{
        public:
            char label_; //edge label
            node * n; //pointer to the second node of the edge
            char label(){
                return label_;
            }
            void setLabel(char a){
                label_=a;
            }

    };
private:
    string name_;//name of node
    int value[2];// 0 for normal and 1 for cancer
    //is node 1=> on or 0=>off 2=>dont care
    //char label_; //edge label

    map<string, edge> adj_;//adjacency list or list of edges
    bool visited_;  //if node is visited in bfs
    typedef  map<string, edge>::iterator it; //iterator over adj_ type

public:

    node(string s){
        name_ =s;
        visited_= false;
        value[0] = 2;
        value[1] = 2;
        //label_ = DONT_CARE;
    }
    node(string s, char l){
        name_ =s;
        visited_= false;
        value[0] = 2;
        value[1] = 2;
        //label_ = l;
    }
    /*int val(){
        return valNormal_;
    }*/
    int val( int i){
    	if (i!=1 && i!= 0) printError("invalid access of node val");
    	return value[i];
    	 
    }
    void setVal(int a, int i){
        if (i!=1 && i!= 0) printError("invalid access of node val");
    		value[i] =a;
    }
    bool visited(){
        return visited_;
    }
    void visit(){
        visited_ =true;
    }
    void unvisit( int version ){
        visited_ = false;
    	value[version] = 2; 
	}
    string name(){
        return name_;
    }
    void setName(string s){
        name_ = s;
    }
    bool isNeighbour(string s){
    //    return adj_.find(s) != adj_.end() ;
    	for(it i = adj_.begin(); i != adj_.end(); i++){
			if (i->second.n->name() == s) return true; 
		} 
		return false;
    }
    void addNeighbour(string s, node *n, char label){
        it i= adj_.find(s);
        if(i == adj_.end() ) {
            //new neighbour
            edge e;
            e.label_ = label;
            e.n = n;
            adj_[s]= e;
        }
		else {
			//reset edge
			adj_[s].label_ = label;
		}
    }
    map<string, edge> getNeighbours(){
        return adj_;
    }
    string printNeighbours(){
        string s="";
        for(it i = adj_.begin(); i != adj_.end(); i++)
        {
            s+="--";
            s+=(i->second.label_);
            s+="--";
            s+=i->first;
            //s+=", ";
        }
        return s;
    }
    char getLabel(string s2){
    	if (isNeighbour(s2)) return XOR;//adj_[s2].label();
    	//else
    	 return NXOR;
    }
};
int usatEdges;
class graph{
    map < string ,node* > nodes;
	typedef map<string ,node*>::iterator itNodes;
public:
    bool bfs(node * root, int init, int version){
		cout<<endl<<version<<endl; 
		cout<<"new root is "<<root->name(); 
		queue< node* > q;
        root->setVal(init, version);
        root->visit();
        q.push(root);
        node* unvisited;
        while(!q.empty()){
            node* curr = q.front();
            //cout<<curr->name()<<" ";
            q.pop();
            map<string, node::edge> adj = curr->getNeighbours();
            for(map<string, node::edge>::iterator i = adj.begin(); i!=adj.end(); i++){
                node::edge next = i->second;
                if(!next.n->visited()){
                	//label unvisited node
                  	next.n->setVal(satisfy(curr->val(version), next.label()), version);
                    q.push(next.n);
                }
                else{
                	//check correctness for labeled/visited nodes
                 	//if some edge is not getting satisfied count unsatisfied edge 
						int satisfyingVal = satisfy(curr->val(version), next.label()) ;
						//if( satisfyingVal != 2 && version == 1) cout<<"\nfound one non dontcare node for abnormal";
						if ( satisfyingVal == 2 ) ; 
						else if( next.n->val(version) == 2){
							next.n->setVal( satisfyingVal, version);
							q.push(next.n);
						}
						else if(next.n->val(version) != satisfyingVal ){
								//cout<<curr->name()<<" "<<curr->val(version)<<"--"<<next.label()<<"-->"<<next.n->name()<<" "<<next.n->val(version);
								//cout<<endl<<satisfyingVal;
								usatEdges++;
								//resetVisit();
								//return false;
						}
					
                }
            }
            curr->visit();
            //cout<<curr->name();
        }
        //one tree from the forest completely labeled
        root = unvisitedNode(); //serch for unlabeled node
        if ( root == NULL ) //all nodes have been visited
            return true;
        return bfs(root, init, version);
    }
    bool initBfs(int init, int version){
        node * root = nodes.begin()->second;
        return bfs(root, init, version);
    }
    node* unvisitedNode(){
        itNodes i;
        for(i = nodes.begin(); i != nodes.end(); i++)
            if( !i->second->visited() ) return i->second;
        return NULL;
    }
    //find satisfying solution to a pair of nodes given an edge for a label
    int satisfy(int a, char label){
        //if label = DONT_CARE then any value can be given. we denote this by 2 
		if ( a == 2 ) return 2;
		if(label == DONT_CARE) return 2;//error TODO
        else if (label == XOR) return (a==1)?0:1;
        else return a;
    }
    void resetVisit( int version ){
        //return;
        for(itNodes i = nodes.begin(); i != nodes.end(); i++){
            i->second->unvisit(version);
            //unlabel all edges to dont Care
            map<string, node::edge> adj = i->second->getNeighbours();
            for ( map< string, node::edge >::iterator j  = adj.begin(); j != adj.end(); j++){
            	j->second.setLabel(DONT_CARE);
            }
        }
        //cout<<"reset visit called";
        //exit(0);
    }
    void addNode(string s){
        if(nodes[s]== NULL) nodes[s] = new node(s);
    }
    void addEdge(string s1, string s2, char label){
        if (s1 == s2) return;
        addNode(s1);
        addNode(s2);
        nodes[s1]->addNeighbour(s2, nodes[s2], label);
        nodes[s2]->addNeighbour(s1, nodes[s1], label);
    }
	void printNodes(){
		ofstream fp;
        fp.open("nodes.txt");
        for(itNodes i = nodes.begin(); i != nodes.end(); i++){
			fp<<i->second->name()<<"\t"<<i->second->val(0)<<"\t"<<i->second->val(1)<<endl;
		}
		fp.close();
	}
    void printGraph(){
        ofstream fp;
        fp.open("graphData.txt");
        for(itNodes i = nodes.begin(); i != nodes.end(); i++){
            fp<<endl<<i->first<<" ==> ";
            fp<<i->second->printNeighbours();
        }
        fp.close();
    }
    void findMinFlips(){
    	//simple version assuming single connected component
    	int minFlips =0;
    	for(itNodes i = nodes.begin(); i != nodes.end(); i++){
    		if( i->second->val(0) == 2 || i->second->val(1) ==2 ) continue; 
    		if(i->second->val(0) != i->second->val(1) ) minFlips++;
    	}
    	cout<<"minimum flips required are "<<min(minFlips, nodes.size()- minFlips);
    }
    char getLabel( string s1, string s2){
    	return nodes[s2]->getLabel(s1);
    }
};
void getCorrelation(std::map< string , std::map <string, float> > &datamap, char* file);
void createGraph(graph &g, char* ppi_file, char* edgeLabelFile, std::map< string , std::map <string, float> > &datamap);

int main(int argc, char* argv[])
{
	if(argc < 4){
		printError("usage ./a.out geneExpression_file ppi_file_name edge_label_output_file");
		
	}   
	
	//get the correlation values
	std::map< string , std::map <string, float> > dataMap;
	getCorrelation(dataMap, argv[1]);
	
	//working on the ppi file now
	//creating graph
	
	graph g;
    createGraph(g, argv[2], argv[3], dataMap);
	
	if(!g.initBfs(1, 0)) { //for normal case
		cout<<"\nERROR: Normal graph unsatisfiable";
		return 1;
	}
	g.printNodes();

    /*
    g.resetVisit(1);
    cout<<"\nworking abnormal data now... \n";
	// change edge labels to cancer data
    {
			ifstream fp; 
			map <string, string> dataMapAbnormal;
				fp.open("abnormal.txt");
				if(!fp) printError("could not open abnormal.txt");
				while(fp.good()){
					string factor;
					fp>>factor;
					string values;
					getline(fp, values);
					if(factor[0]  == '-') continue;
					stringstream s;
					s.str(factor);
					while( getline(s,factor,'/') )
					{
						printError(factor+"\n"+values+"\n");
						dataMapAbnormal[factor] = values;
					}
				}
				fp.close();
			fp.open("Human_PPI_TwoHyb_TAPMSWest_ICD.txt");
			if (!fp ) printError("could not open Human_PPI_TwoHyb_TAPMSWest_ICD.txt");
			string s1,s2;
			//read edges, nodes Normal case
			ofstream fLabel;
			fLabel.open("edgesAbormal.txt");
			string line;
			int toggledEdges=0;
			while(fp.good()){
			  //  getline(fp, line);
				//cout<<line;
				//  if ( line =="") continue;
				//stringstream s;
				fp>>s1;
				fp>>s2;
			//   	fp>>line;
				
				if(s1[2] ==  '/' || s2[2] == '/'|| s1[0] == '0' || s2[0] == '0' ) continue;
				//find edge label
				char label=getLabel(dataMapAbnormal[s1],dataMapAbnormal[s2]); 
				//cout<<label;
				//add edge to graph
				//if ( g.getLabel(s1, s2) != label ) toggledEdges++;
				g.addEdge(s1,s2, label);
				fLabel<<s1<<"\t"<<s2<<"\t"<<label<<endl;
					//cout<<s1<<endl<<s2<<endl;
					 
			}
			cout<<"\nnumber of toggles edges = "<<toggledEdges;
			fp.close();
			fLabel.close();
   			// fp1.close();
			//return 0;

			if(!g.initBfs(1, 1)) { //for abnormal case
				cout<<"\nERROR: Abnormal graph unsatisfiable";
				return 1;
			}
	}
    g.findMinFlips();
	g.printNodes();
    return 0;
	*/

}
void getCorrelation(std::map < string, std::map <string, float> > &dataMap, char* correlation_file){
	ifstream fp;
	fp.open(correlation_file);
	if(!fp) 
		printError("could not open "+string(correlation_file)+"\n");
	while(fp.good()){
		string pro1, pro2;
		float cor;
		fp>>pro1;		fp>>pro2;		fp>>cor;
		if(pro1[0]  == '-'|| pro2[0] == '-') continue;
		
		stringstream s;
		//getting rid of '/' in protein names
		s.str(pro1);
		getline(s,pro1,'/');
		
		s.clear();
		s.str(pro2);
		getline(s,pro2,'/');
		
		map<string , map <string, float> >::iterator it1 = dataMap.find(pro1);
		map< string, map <string, float> >::iterator it2 = dataMap.find(pro2);
		
		if(it1 == dataMap.end() && it2 == dataMap.end()){
			dataMap[pro1] = *(new map <string , float>); 
			dataMap[pro1][pro2] = cor;
		}
		else if(it1 == dataMap.end()){
			dataMap[pro2][pro1] = cor;
		}
		else {
			dataMap[pro1][pro2] = cor;
		}
	}
	fp.close();
			
}
void createGraph(graph &g, char* ppi_file, char* edgeLabels, std::map<string, std::map <string, float> > & dataMap){
	return ;
	ifstream fp;
	fp.open(ppi_file); 
	if (!fp ) 
		printError("could not open "+string(ppi_file)+"\n");
	
	string protein1,protein2;
	ofstream fLabel;
	fLabel.open(edgeLabels);
	
	while(fp.good()){
		//read edges, nodes
	
	   	fp>>protein1; 	fp>>protein2;
	   
		if(protein1[2] ==  '/' || protein2[2] == '/'|| protein1[0] == '0' || protein2[0] == '0' ) continue;
		//find edge label
		char label=getLabel( dataMap, protein1, protein2 ); 
		//add edge to graph
		g.addEdge(protein1,protein2, label);
		fLabel<<protein1<<"\t"<<protein2<<"\t"<<label<<endl;
			//cout<<protein1<<endl<<protein2<<endl;
			 
	}
	fp.close();
	fLabel.close();
}

char getLabel(map<string, map<string, float> > &dataMap, string pro1, string pro2){
	//map<string, map<string, float> >::iterator it = dataMap.find(pro1);
	//char label = DONT_CARE;
	int val = 0;
	if(dataMap.find(pro1)  != dataMap.end()){
		if ( dataMap[pro1].find(pro2) != dataMap[pro1].end() ){
			val = dataMap[pro1][pro2];
		}
	}
	else if (dataMap.find(pro2)!= dataMap.end()){
		if ( dataMap[pro2].find(pro1) != dataMap[pro2].end() ){
			val = dataMap[pro2][pro1];
		}

	}
	if(val >=PEARSON_FACTOR) return NXOR;
	else if (val <=-PEARSON_FACTOR) return XOR;
	else return DONT_CARE;
}

/*
char getLabel(string xstr, string ystr){
    if ( xstr == "" || ystr == "" ) printError("xstr and ystr are of differnet size\n"+xstr+"\n"+ystr );
    vector<double> x,y;
    //extract the x and y vallues from strings
    stringstream s;
    size_t n= 0;
    s.str(xstr);

    double xval, yval;
    //cout<<temp<<endl;
    while(!s.eof()){
        s>>xval;
        x.push_back(xval);
        n++;
     //   cout<<xval<<endl;
    }
    s.clear();
    s.str(ystr);
    //cout<<"*************"<<endl;
    //cout<<temp<<endl;
    while(!s.eof()){
        s>>yval;
        y.push_back(yval);
     //   cout<<yval<<endl;
    }
    //TODO check this
    if(x.size()!= y.size()) {
		//printError(xstr+"\n"+(string)x.size()"\n"+ystr+(string)y.size()+"\n");
	}
	double pearson = Correlation(x,y);
//	cout<<pearson<<endl;
	if (pearson <= -PEARSON_FACTOR) return XOR;
  else if( pearson >= PEARSON_FACTOR) return NXOR;
	else return DONT_CARE;
}
int min(int a, int b){
	return a>b? b:a;
}
double Correlation(const vector<double>& x, const vector<double>& y)
{
	size_t n = min(x.size(), y.size());
	double ex(0), ey(0), sxx(0), syy(0), sxy(0);

	for (size_t i = 0; i < n; i++) { //Find the means.
			ex += x[i];
	  	ey += y[i];
	}
	ex /= n;
	ey /= n;
	for (size_t i = 0; i < n; i++) { //Compute the correlation coeﬃcient.
	  	double xt = x[i] - ex;
	  	double yt = y[i] - ey;
		sxx += xt * xt;
		syy += yt * yt;
		sxy += xt * yt;
	}
	return sxy/(sqrt(sxx*syy)+TINY_VALUE);
}*/
